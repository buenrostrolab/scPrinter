from __future__ import annotations
import matplotlib.axes
import matplotlib.pyplot as plt
import seaborn as sns
from . import motifs
from . import getBias
from .fetch import _get_group_atac, get_group_atac, get_region_atac
from .utils import regionparser, cell_grouping2cell_grouping_idx
from .getFootprint import fastMultiScaleFootprints,rz_conv
from .io import PyPrinter
from .plotting_seq import plot_a_for_plotly, plot_c_for_plotly, plot_g_for_plotly, plot_t_for_plotly
import numpy as np
import pandas as pd
import plotly.graph_objs as go
import pyBigWig
from plotly.subplots import make_subplots
import time
from dna_features_viewer import GraphicFeature, GraphicRecord
from dna_features_viewer.compute_features_levels import compute_features_levels
from scanpy.plotting.palettes import default_20, default_28, default_102
import pyranges
from typing_extensions import Literal
import matplotlib as mpl
from scipy import interpolate

default_colors = {0:'green', 1:'blue', 2:'orange', 3:'red'}

def plot_region_atac(printer: PyPrinter,
                    cell_barcodes: list[str],
                    region: str | pd.DataFrame | pyranges.PyRanges | list[str],
                    ax: matplotlib.axes.Axes | None = None,
                    smooth: bool | int = False,
                     **kwargs):
    '''
    Plot the ATAC-seq signal of a region for **one** group of cells

    Parameters
    ----------
    printer: PyPrinter object
        The printer object you generated by `scprinter.pp.import_fragments` or loaded by `scprinter.load_printer`
    cell_barcodes: list[str]
        List of cell barcodes that you want to visualize
    region: str | pd.DataFrame | pyranges.PyRanges | list[str]
        The region you want to visualize. Scprinter supports all kinds of region format, see `pp` for details
    ax: matplotlib.axes.Axes | None
        The matplotlib axes you want to plot on. If None, will plot on the current axes
    smooth: bool | int
        Whether to smooth the signal. If int, will smooth the signal with a window of size `smooth`
    kwargs:
        Other keyword arguments passed to `plt.bar`

    Returns
    -------

    '''
    atac = get_region_atac(printer,
                           cell_barcodes,
                           region).toarray().sum(axis=0)
    if smooth:
        atac = rz_conv(atac, n=smooth)
    region = regionparser(region, printer)
    if ax is None:
        ax = plt.gca()
    ax.bar(x=np.arange(len(atac)), height=atac, width=1, **kwargs)
    # ax.get_xaxis().set_visible(False)
    ax.set_xticks([0, int(0.5 * atac.shape[-1]), atac.shape[-1]])
    ax.set_xlim(0, atac.shape[-1])
    ax.set_title('Tn5 Insertion on %s:%d-%d' % (region['Chromosome'][0],
                                                region['Start'][0],
                                                region['End'][0]))
    return ax

def plot_group_atac(printer: PyPrinter,
                    cell_grouping: list[list[str]] | list[str] | np.ndarray,
                    group_names: list[str] | str | np.ndarray,
                    region: str | pd.DataFrame | pyranges.PyRanges | list[str],
                    ax: list[matplotlib.axes.Axes] | matplotlib.axes.Axes | None = None,
                    color: list[str] = None,
                    smooth: bool = False,
                    **kwargs):

    '''
    Plot the ATAC-seq signal of a region for **multiple** groups of cells

    Parameters
    ----------
    printer: PyPrinter
        The printer object you generated by `scprinter.pp.import_fragments` or loaded by `scprinter.load_printer`
    cell_grouping: list[list[str]] | list[str] | np.ndarray
        The cell grouping you want to visualize. See `pp` for details
    group_names: list[str] | str | np.ndarray
        The names of the groups you want to visualize.
        If `cell_grouping` is a list of cell barcodes, `group_names` should be a list of strings with the same length as `cell_grouping`
    region: str | pd.DataFrame | pyranges.PyRanges | list[str]
        The region you want to visualize. Scprinter supports all kinds of region format, see `pp` for details
    ax: list[matplotlib.axes.Axes] | matplotlib.axes.Axes | None
        The matplotlib axes you want to plot on. If list of axes (same length as cell_grouping),
        the insertion would be plot on separate axes.
        If one axes, the insertion would be plot on the same axes, but with different color.
        If None, will plot on the current axes
    color: list[str] | None
        The color of the barplot. If None, will use the default color palette.
        If list of colors (same length as cell_grouping), the insertion would be plot on the same axes,
        but with different color.
    smooth: bool | int
        Whether to smooth the signal. If int, will smooth the signal with a window of size `smooth`
    kwargs
        Other keyword arguments passed to `plt.bar`

    Returns
    -------

    '''

    if type(group_names) not in [np.ndarray, list]:
        group_names = [group_names]
        cell_grouping = [cell_grouping]

    atacs = get_group_atac(printer,
                           cell_grouping,
                           region)
    if smooth:
        atacs = rz_conv(atacs, n=smooth)

    region = regionparser(region, printer)
    if ax is None:
        ax = plt.gca()
    if type(ax) is list:
        for atac, ax_, group_name in zip(atacs, ax, group_names):
            x = np.arange(len(atac))
            ax_.bar(x=x, height=atac, width=1,color=color, **kwargs)
            ax_.set_xticks([0, int(0.5 * atacs.shape[-1]), atacs.shape[-1]])
            ax_.set_xlim(0, atacs.shape[-1])
            # ax_.get_xaxis().set_visible(False)
            ax_.set_title('Tn5 Insertion on %s:%d-%d - %s' % (region['Chromosome'][0],
                                                region['Start'][0],
                                                region['End'][0], str(group_name)))
            plt.tight_layout()
        return
    else:
        x = np.concatenate([np.arange(atacs.shape[-1])] * len(atacs), axis=0)
        y = atacs.reshape((-1))

        if color is None:
            if len(group_names) <= 20:
                color = default_20
            elif len(group_names) <= 28:
                color = default_28
            else:
                color = default_102
        cl = np.repeat(color[:len(group_names)],  atacs.shape[-1])
        ax.bar(x=x, height=y, color=cl, width=1, linewidth=0, **kwargs)

        labels = group_names
        handles = [plt.Rectangle((0, 0), 1, 1, color=color[i]) for i in range(len(labels))]
        plt.legend(handles, labels)
        # ax.get_xaxis().set_visible(False)
        ax.set_xticks([0, int(0.5 * atacs.shape[-1]), atacs.shape[-1]])
        ax.set_xlim(0, atacs.shape[-1])
        ax.set_title('Tn5 Insertion on %s:%d-%d'% (region['Chromosome'][0],
                                                region['Start'][0],
                                                region['End'][0]))
        return


def plot_binding_score(printer: PyPrinter,
                       save_key: str,
                       group_names: list[str] | str | np.ndarray,
                       region: str | pd.DataFrame | pyranges.PyRanges | list[str],
                       kind: Literal['bar', 'heatmap'] = 'bar',
                       ax: list[matplotlib.axes.Axes] | matplotlib.axes.Axes | None = None,
                       color: list[str] = None,
                       cmap='Blues',
                       vmin: float = 0.1,
                       vmax: float = 1.0,
                       row_label: list[str] | None = None,
                       row_cluster: bool = False,
                       legend: bool = True,
                       **kwargs):
    """
    Plot the binding score of a region for **multiple** groups of cells

    Parameters
    ----------
    printer: PyPrinter object
        The printer object you generated by `scprinter.pp.import_fragments` or loaded by `scprinter.load_printer`
    save_key: str
        The key of the binding score you want to visualize (the one you use as `save_key`
        when calling `tl.get_binding_score`).
        You can get the available keys by `printer.bindingscoreadata.keys()`
    group_names: list[str] | str | np.ndarray
        The names of the groups you want to visualize. These must be included in the ones you used in `tl.get_binding_score`
    region: str | pd.DataFrame | pyranges.PyRanges | list[str]
        The region you want to visualize. Scprinter supports all kinds of region format, see `pp` for details
    kind: Literal['bar', 'heatmap']
        The kind of plot you want to generate. If 'bar', will generate a barplot (x-axis genome coord, y-axis binding score).
         If 'heatmap', will generate a heatmap (x-axis genome coord, y-axis cell grouping)
    ax: list[matplotlib.axes.Axes] | matplotlib.axes.Axes | None
        The matplotlib axes you want to plot on. If list of axes (same length as cell_grouping), the insertion would be plot on separate axes.
        If one axes, the insertion would be plot on the same axes, but with different color. If None, will plot on the current axes
    color: list[str] | None
        The color of the barplot. If None, will use the default color palette.
    cmap: str
        The colormap of the heatmap.
    vmin: float
        The minimum value of the heatmap
    vmax: float
        The maximum value of the heatmap
    row_label: list[str] | None
        The color of the heatmap for each group. If None, will not plot
    kwargs:
        Other keyword arguments passed to `plt.bar`

    Returns
    -------

    Coming Soon
    ----
    1. Add support for compute on the fly

    """
    if type(group_names) not in [np.ndarray, list]:
        group_names = [group_names]

    adata = printer.bindingscoreadata[save_key]
    region = regionparser(region, printer)
    region_identifier = '%s:%d-%d' % (str(region['Chromosome'][0]),
                                    region['Start'][0],
                                    region['End'][0])
    try:
        select_group = adata.obs_ix(np.array(group_names).astype('str'))
    except:
        select_group =adata.obs.loc[group_names]['id']

    data = adata.obsm[region_identifier][select_group]



    if kind == 'bar':
        if ax is None:
            ax = plt.gca()
        if type(ax) is list:
            for score, ax_, group_name in zip(data, ax, group_names):
                ax_.bar(x=np.arange(len(score)), height=score, width=1, color=color, **kwargs)

                width = len(score)
                ax_.set_xticks([0, int(0.5 * width), width])
                ax_.set_xlim(0, width)
                ax_.set_title('Tn5 Insertion on %s:%d-%d - %s' % (region['Chromosome'][0],
                                                    region['Start'][0],
                                                    region['End'][0], str(group_name)))
                plt.tight_layout()
            return
        else:
            x = np.concatenate([np.arange(data.shape[-1])] * len(data), axis=0)
            y = data.reshape((-1))
            if color is None:
                if len(group_names) <= 20:
                    color = default_20
                elif len(group_names) <= 28:
                    color = default_28
                else:
                    color = default_102
            cl = np.repeat(color[:len(group_names)], data.shape[-1])
            ax.bar(x=x, height=y, color=cl, width=1, **kwargs)
            labels = group_names
            if legend:
                handles = [plt.Rectangle((0, 0), 1, 1, color=color[i]) for i in range(len(labels))]
                plt.legend(handles, labels)

            width = data.shape[-1]
            ax.set_xticks([0, int(0.5 * width), width])
            ax.set_xlim(0, width)
            ax.set_title('Binding Score on %s:%d-%d' % (region['Chromosome'][0],
                                                    region['Start'][0],
                                                    region['End'][0]))
            return ax
    elif kind == 'heatmap':

        if row_label is not None:
            unique_label = np.unique(row_label)

            if len(unique_label) <= 28:
                color = default_28
            else:
                color = default_102

            color = {ct: cl for ct, cl in zip(unique_label, color)}
            row_color = np.array([color[xx] for xx in row_label])
        else:
            row_color = row_label

        cg = sns.clustermap(data, cmap=cmap, vmin=vmin, vmax=vmax, **kwargs, row_cluster=row_cluster, col_cluster=False,
                       row_colors=row_color,cbar_pos=None, dendrogram_ratio=0.0)
        ax_ = cg.ax_heatmap
        ax_.get_xaxis().set_visible(False)
        ax_.get_yaxis().set_visible(False)

        from matplotlib.patches import Patch
        handles = [Patch(facecolor=color[name]) for name in color]
        if legend:
            plt.legend(handles, color, title='Species',
                       bbox_to_anchor=(1.1, 1), bbox_transform=plt.gcf().transFigure, loc='upper right', frameon=False)

        plt.title('Binding Score on %s:%d-%d' % (region['Chromosome'][0],
                                                    region['Start'][0],
                                                    region['End'][0]))
        return

from matplotlib.scale import Transform, ScaleBase, LogLocator, LogFormatterSciNotation, NullFormatter, NullLocator
from matplotlib.ticker import Locator, AutoLocator, _decade_less_equal, _decade_less, _decade_greater_equal, _decade_greater
from matplotlib import _api


class LogAddTransform(Transform):
    input_dims = output_dims = 1

    def __init__(self, base, nonpositive='clip', offset=0.0):
        super().__init__()
        if base <= 0 or base == 1:
            raise ValueError('The log base cannot be <= 0 or == 1')
        self.base = base
        self.offset= offset
        self._clip = _api.check_getitem(
            {"clip": True, "mask": False}, nonpositive=nonpositive)

    def __str__(self):
        return "{}(base={}, nonpositive={!r})".format(
            type(self).__name__, self.base, "clip" if self._clip else "mask")

    def transform_non_affine(self, a):
        # Ignore invalid values due to nans being passed to the transform.
        with np.errstate(divide="ignore", invalid="ignore"):
            log = {np.e: np.log, 2: np.log2, 10: np.log10}.get(self.base)
            if log:  # If possible, do everything in a single call to NumPy.
                out = log(a+ self.offset)
            else:
                out = np.log(a+ self.offset)
                out /= np.log(self.base)
            if self._clip:
                # SVG spec says that conforming viewers must support values up
                # to 3.4e38 (C float); however experiments suggest that
                # Inkscape (which uses cairo for rendering) runs into cairo's
                # 24-bit limit (which is apparently shared by Agg).
                # Ghostscript (used for pdf rendering appears to overflow even
                # earlier, with the max value around 2 ** 15 for the tests to
                # pass. On the other hand, in practice, we want to clip beyond
                #     np.log10(np.nextafter(0, 1)) ~ -323
                # so 1000 seems safe.
                out[a < 0] = -1000
        return out

    def inverted(self):
        return InvertedLogAddTransform(self.base, self.offset)

class InvertedLogAddTransform(Transform):
    input_dims = output_dims = 1

    def __init__(self, base, offset=0.0):
        super().__init__()
        self.base = base
        self.offset = offset

    def __str__(self):
        return "{}(base={})".format(type(self).__name__, self.base)

    def transform_non_affine(self, a):
        out = np.power(self.base, a) - self.offset
        print (out)
        return out

    def inverted(self):
        return LogAddTransform(self.base, self.offset)

class LogAddScale(ScaleBase):
    """
    A standard logarithmic scale.  Care is taken to only plot positive values.
    """
    name = 'log'

    def __init__(self, axis, *, base=10, subs=None, nonpositive="clip", offset=0.0):
        """
        Parameters
        ----------
        axis : `~matplotlib.axis.Axis`
            The axis for the scale.
        base : float, default: 10
            The base of the logarithm.
        nonpositive : {'clip', 'mask'}, default: 'clip'
            Determines the behavior for non-positive values. They can either
            be masked as invalid, or clipped to a very small positive number.
        subs : sequence of int, default: None
            Where to place the subticks between each major tick.  For example,
            in a log10 scale, ``[2, 3, 4, 5, 6, 7, 8, 9]`` will place 8
            logarithmically spaced minor ticks between each major tick.
        """
        self._transform = LogAddTransform(base, nonpositive, offset)
        self.subs = subs
        self.offset = offset

    base = property(lambda self: self._transform.base)

    def set_default_locators_and_formatters(self, axis):
        # docstring inherited
        axis.set_major_locator(NullLocator())
        axis.set_major_formatter(NullFormatter())
        axis.set_minor_locator(NullLocator())
        axis.set_minor_formatter(
            NullFormatter())

    def get_transform(self):
        """Return the `.LogTransform` associated with this scale."""
        return self._transform

    def limit_range_for_scale(self, vmin, vmax, minpos):
        """Limit the domain to positive values."""
        if not np.isfinite(minpos):
            minpos = 1e-300  # Should rarely (if ever) have a visible effect.

        return (minpos if vmin <= 0 else vmin,
                minpos if vmax <= 0 else vmax)

def plot_footprints(printer: PyPrinter,
                    save_key: str | None,
                    group_names: list[str] | str | np.ndarray,
                    region: str | pd.DataFrame | pyranges.PyRanges | list[str],
                    cell_grouping: list[list[str]] | list[str] | np.ndarray | None = None,
                    scales: list[int] | np.ndarray | None=None,
                    stack: bool = False,
                    ax: list[matplotlib.axes.Axes] | matplotlib.axes.Axes | None  = None,
                    cmap='Blues',
                    vmin: float = 0.5,
                    vmax: float =2.0,
                    figsize: tuple | Literal['auto'] = 'auto',
                    edge_mode: Literal['remove', 'zeros', 'nothing'] = 'remove',
                    row_label: list[str] | None = None,
                    legend: bool = True,
                    log_scale: bool = False,
                    log_offset: float = 1.1,
                    add_ticks: bool = False,
                    **kwargs
                    ):
    """
    Plot the footprints of a region for **multiple** groups of cells

    Parameters
    ----------
    printer: PyPrinter object
        The printer object you generated by `scprinter.pp.import_fragments` or loaded by `scprinter.load_printer`
    save_key: str | None
        The key of the footprints you want to visualize (the one you use as `save_key` when calling `tl.get_footprints`).
        You can get the available keys by `printer.footprintsadata.keys()`
        If None, will calculate the footprints on the fly
    group_names: list[str] | str | np.ndarray
        The names of the groups you want to visualize. These must be included in the ones you used in `tl.get_footprints`
        (unless save_key is None, and you specify cell_grouping later)
    region: str | pd.DataFrame | pyranges.PyRanges | list[str]
        The region you want to visualize. Scprinter supports all kinds of region format, see `pp` for details
    cell_grouping: list[list[str]] | list[str] | np.ndarray | None
        Must be specified and will only be used when save_key is None. This will be used to calculate the footprints on the fly.
        See more details in `tl.get_footprints`
    scales: list[int] | np.ndarray | None
        The scale you want to visualize. If None, will visualize all the scales
    stack: bool
        Whether to stack the footprints across cell groups into one axis. This only works when there are only one scale
    ax: list[matplotlib.axes.Axes] | matplotlib.axes.Axes | None
        The list of axes you want to plot on. If None, will automatically generate a list of axes, same length as group_names to plot on
    cmap
        colormap for the heatmap
    vmin: float
        vmin for the heatmap
    vmax: float
        vmax for the heatmap
    figsize: tuple | Literal['auto']:
        The size of the figure. If 'auto', will automatically generate the size
    edge_mode: Literal['remove', 'zeros', 'nothing']
        How to deal with the first and last 100bp of the heatmap. If 'remove', will remove the edge of the heatmap.
        If zeros, will fill the edge with zeros. If 'nothing', will not do anything
    row_label: list[str] | None
        The label of the cell groups.
    legend: bool
        Whether to show the legend for row_labels
    log_scale: bool
        Whether to use log scale for the heatmap y-axis (extending TF footprints, and shrink nucleosome footprints)
    log_offset: float
        The offset for the log scale. Sth like 1.1 works pretty well, this controls how much TF
        is extended and how much nucleosome is shrinked
    add_ticks: bool
        Whether to add ticks for the heatmap y-axis (Recommend to be true when using log_scale)
    kwargs:
        Other arguments for `sns.heatmap`

    Returns
    -------
    """
    log_offset = int(10 ** log_offset)
    if stack and type(scales) is not int:
        if len(scales) > 1:
            raise ValueError('You can only stack the footprints when there is only one scale')

    if type(group_names) not in [np.ndarray, list]:
        group_names = [group_names]

    if cell_grouping is not None:
        if type(cell_grouping[0]) not in [np.ndarray, list]:
            cell_grouping = [cell_grouping]

    region = regionparser(region, printer)
    region_identifier = '%s:%d-%d' % (str(region['Chromosome'][0]),
                                      region['Start'][0],
                                      region['End'][0])

    if save_key is not None:
        adata = printer.footprintsadata[save_key]
        try:
            select_group = adata.obs_ix(np.array(group_names).astype('str'))
        except:
            select_group = adata.obs.loc[group_names]['id']
        if scales is None:
            scales = slice(None)
            scales_name = np.array(adata.uns['scales'])
        else:
            scales = np.array([list(adata.uns['scales']).index(s) for s in scales])
            scales_name = scales
        data = adata.obsm[region_identifier][select_group][:, scales]
    else:
        cell_grouping = cell_grouping2cell_grouping_idx(printer,
                                                        cell_grouping)
        atac = _get_group_atac(printer,
                           cell_grouping,
                           region)
        bias = getBias.getPrecomputedBias(printer.insertion_file.uns['bias_path'],
                   region, savePath=None)[0]

        data = fastMultiScaleFootprints(atac,
                 bias,
                 printer.dispersionModel,
                 modes=scales if scales is not None else np.arange(2,101)
                 )
        scales_name = scales if scales is not None else np.arange(2,101)


    if not stack:
        if ax is None:
            if figsize == 'auto':
                figsize = (4, 4 * len(group_names))
            fig, axs = plt.subplots(len(group_names), 1, figsize=figsize)
            if len(group_names) > 1:
                ax = list(axs)
            else:
                ax = [axs]
        elif type(ax) not in [list, np.ndarray]:
            ax = [ax]

        if type(ax) is list:
            for score, ax_, group_name in zip(data, ax, group_names):
                width = score.shape[-1]
                if edge_mode == 'remove':
                    score = score[:, 100:-100]
                    x = np.arange(100, width-100)
                elif edge_mode == 'zeros':
                    score = score[:,]
                    score[:, :100] = 0
                    score[:,-100:] = 0
                    x = np.arange(width)
                else:
                    score = score[:, ]
                    x = np.arange(width)
                # if log_offset > 0:
                #     score = np.concatenate([
                #         np.zeros((log_offset, width)),
                #         score,
                #     ])
                # index = np.concatenate([np.zeros(log_offset),
                #          np.array(scales_name) * 2])
                index = np.array(scales_name) * 2
                df = pd.DataFrame(score, columns=x, index = index)
                ax_ = sns.heatmap(df, ax=ax_,
                            cmap=cmap, square=False, cbar=False, vmax=vmax, vmin=vmin, **kwargs)
                ax_.get_xaxis().set_visible(False)

                ax_.set_ylim(0, len(df))
                if log_scale:
                    ax_.set_yscale(LogAddScale(axis=ax_.get_yaxis(),
                                               subs=[0],
                                               offset=log_offset))
                if not add_ticks:
                    ax_.get_yaxis().set_visible(False)
                else:
                    ticklabel = np.array([50, 100, 150, 200])
                    index = list(index.astype('int'))
                    ticks = np.array([index.index(int(xx*0.5)*2) for xx in ticklabel])#+log_offset
                    ax_.set_yticks(ticks=ticks, labels=ticklabel)
                ax_.set_title('Multiscale footprints\n%s:%d-%d\n%s' % (region['Chromosome'][0],
                                                    region['Start'][0],
                                                    region['End'][0], str(group_name)))

        plt.tight_layout()
        return
    else:
        data = data[:, 0, :]
        if row_label is not None:
            unique_label = np.unique(row_label)

            if len(unique_label) <= 28:
                color = default_28
            else:
                color = default_102

            color = {ct: cl for ct, cl in zip(unique_label, color)}
            row_color = np.array([color[xx] for xx in row_label])
        else:
            row_color = row_label
        if figsize == 'auto':
            figsize = (4, 4)
        cg = sns.clustermap(data, cmap=cmap, vmin=vmin, vmax=vmax, row_cluster=False, col_cluster=False,
                            row_colors=row_color, cbar_pos=None, dendrogram_ratio=0.0, figsize=figsize, **kwargs)
        ax_ = cg.ax_heatmap
        ax_.get_xaxis().set_visible(False)
        ax_.get_yaxis().set_visible(False)

        from matplotlib.patches import Patch
        handles = [Patch(facecolor=color[name]) for name in color]
        if legend:
            plt.legend(handles, color, title='row label',
                       bbox_to_anchor=(1.1, 1), bbox_transform=plt.gcf().transFigure, loc='upper right', frameon=False)
        return

def _bigwig_footprint(insertion, bias, chrom, s, e, pad=0, extra=None):
    # insertion = pyBigWig.open(insertion, 'r')
    # bias = pyBigWig.open(bias, 'r')
    b = np.array(bias.values(chrom, s - pad, e + pad))
    nan1 = np.sum(np.isnan(b))
    b[np.isnan(b)] = 0.0

    a = np.array(insertion.values(chrom, s - pad, e + pad))
    a[np.isnan(a)] = 0.0
    nan2 = np.sum(np.isnan(a))
    v = fastMultiScaleFootprints(a[None],
                                 b,
                                 dispModels,
                                 modes=np.arange(2, 101)
                                 )[0]
    # print (nan1, nan2)
    if pad > 0:
        v = v[:, pad:-pad]
    if extra is not None:
        return v, extra
    return v


def plot_gene_match_static(printer: PyPrinter,
                           region: str | pd.DataFrame | pyranges.PyRanges | list[str],
                           ax: matplotlib.axes.Axes,
                           **kwargs):
    """
    Plot reference genome gene annotation

    Parameters
    ----------
    printer: PyPrinter
        The printer object you generated by `scprinter.pp.import_fragments` or loaded by `scprinter.load_printer`
    region:
        The region you want to plot.
    ax:
        The matplotlib axes you want to plot on.
    kwargs
        Other arguments for `GraphicRecord.plot`
    Returns
    -------

    """

    gffdb = printer.gff_db
    region = regionparser(region, printer)
    chrom, s, e = str(region['Chromosome'][0]), region['Start'][0], region['End'][0]

    genes = list(gffdb.region(seqid=chrom, start=s, end=e))
    feats = []
    for f in genes:
        if f.featuretype == 'gene':
            feats.append(GraphicFeature(
                start=f.start - s,
                end=min(f.end - s, e-s),
                strand=f.strand,
                color="#d3d3d3",
                label=f.attributes['gene_name'][0]
            ))
    record = GraphicRecord(sequence_length=e - s, features=feats)
    _ = record.plot(ax=ax, **kwargs)


def plot_motif_match_static(motif: motifs.Motifs,
                            printer: PyPrinter,
                            region: str | pd.DataFrame | pyranges.PyRanges | list[str],
                            ax: matplotlib.axes.Axes,
                            strand=True,
                            clean=True,
                            color_dict=None,):
    """
    Plot motif match

    Parameters
    ----------
    motif: motifs.Motifs
        The motif scanner you want to use for the binding score calculation.
    printer: PyPrinter
        The printer object you generated by `scprinter.pp.import_fragments` or loaded by `scprinter.load_printer`
    region: str | pd.DataFrame | pyranges.PyRanges | list[str]
        The region you want to plot.
    ax: matplotlib.axes.Axes
        The matplotlib axes you want to plot on.

    Returns
    -------

    """
    tfs = list(motif.tfs)
    if len(tfs) <= 20:
        color = default_20
    elif len(tfs) <= 28:
        color = default_28
    else:
        color = default_102
    if color_dict is None:
        color_dict = {tf: color[i] for i, tf in enumerate(tfs)}
    region = regionparser(region, printer)
    chrom, s, e = str(region['Chromosome'][0]), region['Start'][0], region['End'][0]
    motif_matchs = motif.scan_motif([[chrom, s, e, "+"]],
                                    clean=clean, strand=strand)
    # [bed_coord['chr'], bed_coord['start'],
    #   bed_coord['end'], bed_coord['index'],
    #   name, score,
    #   strand, motif_start, motif_end

    features = [GraphicFeature(start=match[7] ,
                               end=match[8] ,
                               strand=match[6],
                               color=color_dict[match[4]],
                               label=match[4]) for i, match in enumerate(motif_matchs)]
    record = GraphicRecord(sequence_length=e - s, features=features)
    _ = record.plot(ax=ax)


def _create_motif_match_df(motif, chrom, s, e):
    motif_matchs = motif.scan_motif([[chrom, int(s), int(e), "+"]],
                                    clean=True)
    if len(motif_matchs) == 0:
        return None

    features = [GraphicFeature(start=match[7],
                               end=match[8],
                               strand=match[6],
                               color=match[4],
                               label=match[4]) for match in motif_matchs]
    # record = GraphicRecord(sequence_length=init_e - init_s, features=features)
    rec = compute_features_levels(features)
    df = pd.DataFrame(
        [dict(Level=rec[key], Start=key.start + s, Finish=key.end + s, TF=str(key.label)) for key in rec])
    df.index = df['TF']
    df['delta'] = df['Finish'] - df['Start']
    return df

def _create_motif_match_trace(motif, chrom, s, e):
    tfs = list(motif.tfs)
    max_level = 0
    if len(tfs) <= 20:
        color = default_20
    elif len(tfs) <= 28:
        color = default_28
    else:
        color = list(default_102) + list(default_20) + list(default_28) + list(default_102) + list(default_20) + list(default_28)
    pal = {tf:c for (tf, c) in zip(tfs, color)}

    df = _create_motif_match_df(motif, chrom, s, e)
    traces = []
    for tf in tfs[::-1]:
        try:
            tf_df = df.loc[tf]
            base, x, y = np.array(tf_df['Start']), np.array(tf_df['delta']), np.array(tf_df['Level'])
            max_level = max(max_level, np.max(y))
        except Exception as e:
            # print (e)
            base, x, y = [], [], []

        trace = go.Bar({
            'alignmentgroup': 'True',
            'base': base,
            'hovertemplate': 'TF='+tf+'<br>Start=%{base:,}<br>End=%{x:,}<extra></extra>',
            'legendgroup': tf,
            'marker': {'color': pal[tf], 'pattern': {'shape': ''}},
            'name': tf,
            'offsetgroup': tf,
            'orientation': 'h',
            'showlegend': True,
            'textposition': 'auto',
            'x': x,
            'xaxis': 'x',
            'y': y,
            'yaxis': 'y',
             'width': 1
        })

        traces.append(trace)

    return traces, max_level

def _create_gene_match_df(gffdb, chrom, s, e):
    genes = list(gffdb.region(seqid=chrom, start=s, end=e))
    if len(genes) == 0:
        return None

    feats = []
    for f in genes:
        if f.featuretype == 'gene':
            feats.append(GraphicFeature(
                start=f.start,
                end=f.end,
                strand=f.strand,
                color=f.strand,
                label=f.attributes['gene_name'][0]
            ))

    rec = compute_features_levels(feats)
    df = pd.DataFrame(
        [dict(Level=rec[key], Start=key.start, Finish=key.end, Gene=str(key.label), Strand=str(key.strand)) for key in rec])
    df['delta'] = df['Finish'] - df['Start']
    return df

def _create_gene_match_trace(gffdb, chrom, s, e, level_offset=0):
    df = _create_gene_match_df(gffdb, chrom, s, e)
    try:
        base, x, y, gene, strand = (np.array(df['Start']), np.array(df['delta']),
                                    np.array(df['Level']), np.array(df['Gene']),
                                    np.array(df['Strand']))
        y += level_offset
    except:
        base, x, y, gene, strand = [], [], [], [], []
    gene = [xx + "(" + yy + ")" for xx,yy in zip(gene, strand)]
    trace = go.Bar({
        'alignmentgroup': 'True',
        'base': base,
        'text': gene,
        'hovertemplate': '%{text}<br>Start=%{base:,}<br>End=%{x:,}<extra></extra>',
        'legendgroup': 'Gene',
        'marker': {'color': '#808080', 'pattern': {'shape': ''}},
        'name': 'Gene',
        'offsetgroup': 'Gene',
        'orientation': 'h',
        'showlegend': True,
        'textposition': 'inside',
        'insidetextanchor': 'start',
        'x': x,
        'xaxis': 'x',
        'y': y,
        'yaxis': 'y'
    })
    return trace



def plotly_plot_weights(array,
                        height_padding_factor=0.2,
                        clip_percent=0.01,
                        colors=default_colors,
                        plot_funcs={"A": plot_a_for_plotly,
                                    "C": plot_c_for_plotly,
                                    "G": plot_g_for_plotly,
                                    "T": plot_t_for_plotly},
                        highlight={},
                        start_pos=0,
                        xref='x',
                        yref='y'):
    # Initial checks on array
    if len(array.shape) == 3:
        array = np.squeeze(array)
    assert len(array.shape) == 2, array.shape
    if (array.shape[0] == 4 and array.shape[1] != 4):
        array = array.transpose(1, 0)
    assert array.shape[1] == 4

    max_pos_height = 0.0
    min_neg_height = 0.0
    heights_at_positions = []
    depths_at_positions = []

    all_shapes = []

    array_sum_pos = np.sum(array * (array > 0), axis=-1)
    array_sum_neg = -np.sum(array * (array < 0), axis=-1)
    sum = np.concatenate([array_sum_pos, array_sum_neg], axis=-1)
    # sum = sum[sum != 0]
    cutoff = np.max(sum) * clip_percent
    array[np.abs(array) < cutoff] = 0.0

    for i in range(array.shape[0]):
        acgt_vals = sorted(enumerate(array[i, :]), key=lambda x: abs(x[1]))
        positive_height_so_far = 0.0
        negative_height_so_far = 0.0

        for idx, val in acgt_vals:
            letter = ["A", "C", "G", "T"][idx]
            plot_func = plot_funcs[letter]
            color = colors[idx]

            if val > 0:
                base = positive_height_so_far
                positive_height_so_far += val
            else:
                base = negative_height_so_far
                negative_height_so_far += val
            if np.abs(val) > 0:
                all_shapes.extend(plot_func(base=base, left_edge=i+start_pos, height=val, color=color,
                                            xref=xref, yref=yref))

            max_pos_height = max(max_pos_height, positive_height_so_far)
            min_neg_height = min(min_neg_height, negative_height_so_far)
            heights_at_positions.append(positive_height_so_far)
            depths_at_positions.append(negative_height_so_far)
    # print(len(all_shapes))
    # Highlight specified positions
    for color in highlight:
        for start_pos, end_pos in highlight[color]:
            min_depth = np.min(depths_at_positions[start_pos:end_pos])
            max_height = np.max(heights_at_positions[start_pos:end_pos])

            all_shapes.append({
                'type': 'rect',
                'x0': start_pos,
                'y0': min_depth,
                'x1': end_pos,
                'y1': max_height,
                'line': {
                    'color': color,
                    'width': 2
                },
                'xref': xref,
                'yref': yref,
                'fillcolor': 'transparent'
            })

    height_padding = max(abs(min_neg_height) * height_padding_factor,
                         abs(max_pos_height) * height_padding_factor)

    return all_shapes, min_neg_height, max_pos_height, height_padding


def parse_seq_importance(seq, importance):
    v = np.zeros((len(seq), 4))
    dict = {"A":0, "C":1, "G":2, "T":3}
    for i, (s, imp) in enumerate(zip(seq, importance)):
        v[i, dict[s]] = imp
    return v


def sync_footprints(printer: PyPrinter,
                    group_names: str | list[str],
                    init_region: str,
                    motif_scanner: motifs.Motifs | None = None,
                    plotgenes: bool = False,
                    seq_importance: str | list[str] | None = None,
                    width: int = 600,
                    vmin: float = 0.5,
                    vmax: float = 2.0,
                    ):

    """
    Synced visualization of multiscale footprints
    You must run `tl.sync_footprints` first with the same `group_names` to generate the
    `group_bigwig` in `adata.uns['group_bigwig']`

    Parameters
    ----------
    printer: PyPrinter
        The printer object.
    group_names: str | list[str]
        group_names, these must be included in the `group_bigwig` in `adata.uns['group_bigwig']`
    init_region: str
        The initial region to plot, e.g. 'chr1:1000-2000'
    motif_scanner: motifs.Motifs | None
        The motif scanner object, if None, no motif will be plotted
    plotgenes: bool
        Whether to plot reference gene annotation. Default: False
    seq_importance: str
        The bigwig file of sequence importance. If None, no sequence importance will be plotted
        When provided as a list, it has to be the same length of the list of group names. If you miss certain elements,
        put None instead.
    width: int
        The width of the plot. Default: 600

    Returns
    -------

    """

    # get info for plot tss gene
    gffdb = printer.gff_db if plotgenes else None
    if motif_scanner is None:
        tfs = []
    else:
        tfs = list(motif_scanner.tfs)
    # Set global dispersion model for footprinting
    global dispModels
    dispModels = printer.dispersionModel

    # get the initial plot region
    init_region = regionparser(init_region, printer)
    chrom, init_s, init_e = init_region['Chromosome'][0], int(init_region['Start']),int(init_region['End'])

    # prep group_names & seq importance to make them both as list
    if type(group_names) not in [np.ndarray, list]:
        group_names = [group_names]
    group_names = [str(xx) for xx in group_names]

    if type(seq_importance) not in [np.ndarray, list]:
        seq_importance = [seq_importance] * len(group_names)


    assert 'group_bigwig' in printer.insertion_file.uns, "no group_bigwig detected, call pp.sync_footprints first"
    group_bigwig = printer.insertion_file.uns['group_bigwig']
    group_bigwig = {name:pyBigWig.open(group_bigwig[name], 'r') for name in group_bigwig}

    group_seq_importance = {}
    valid_seq_importance = 0

    # Content includes:
    # - Refseq
    # - TF matching results
    # - len(group_names) x [seq_importance, multiscale footprint]

    per_foot_height = 500 * width / 600
    per_importance_height = 100 * width / 600
    per_TF_height = 30 * width / 600
    annotation_first = 1 if motif_scanner is not None or gffdb is not None else 0
    # gffdb can be regarded as 1 additional TF though
    TF_track_height = per_TF_height * ((min((len(tfs) / 2 + 1), 8) + (gffdb is not None)))


    subplot_titles = ['Annotations'] * annotation_first
    row_heights = [TF_track_height] * annotation_first
    footprint_axes = {}
    seq_axes = {}

    ct = annotation_first
    for name, importance in zip(group_names, seq_importance):
        if importance is None:
            continue
        elif '.bw' in importance:
            group_seq_importance[name] = pyBigWig.open(importance, 'r')
            subplot_titles.append(name)
            row_heights.append(per_importance_height)
            seq_axes[name] = '' if ct == 0 else str(ct+1)
            ct += 1
            valid_seq_importance += 1

        # elif '.h5' in importance:
        #     subplot_titles.append(name)
        #     row_heights.append(per_importance_height)
        #     valid_seq_importance += 1
        #     print("importance on the fly, not implemented yet")

        subplot_titles.append(name)
        row_heights.append(per_foot_height)
        footprint_axes[name] = '' if ct == 0 else str(ct+1)
        ct += 1

    foot_track_height = per_foot_height * len(group_names)
    importance_track_height = per_importance_height * valid_seq_importance
    fig_height = foot_track_height + TF_track_height + importance_track_height

    row_heights = list(np.array(row_heights) / np.sum(row_heights))


    fig = make_subplots(rows=len(subplot_titles),
                        cols=1,
                        subplot_titles=subplot_titles,
                        row_heights=row_heights,
                        horizontal_spacing=0,
                        vertical_spacing=(50 / per_foot_height / len(group_names)))

    if motif_scanner is not None:
        figure1_traces, max_level = _create_motif_match_trace(motif_scanner, chrom, init_s, init_e)
        for traces in figure1_traces:
            fig.append_trace(traces, row=1, col=1)
        footprint_data_start = len(figure1_traces)
    else:
        footprint_data_start = 0
        max_level = 0

    if gffdb is not None:
        fig.append_trace(_create_gene_match_trace(gffdb, chrom, init_s, init_e, max_level + 1),
                         row=1, col=1)
        footprint_data_start += 1
    if group_names[0] in group_seq_importance:
        footprint_data_start += 1
    all_shapes = []
    for i, name in enumerate(group_names):
        if name in group_seq_importance:
            importance = group_seq_importance[name].values(chrom, init_s, init_e)
            xref = 'x' + seq_axes[name]
            yref = 'y' + seq_axes[name]
            seq = printer.genome.fetch_seq(chrom, init_s, init_e)
            seq_imp = parse_seq_importance(seq, importance)
            (all_shapes_, min_neg_height,
             max_pos_height, height_padding) = plotly_plot_weights(seq_imp,
                                                                   xref=xref,
                                                                   yref=yref,
                                                                   start_pos=init_s)
            row = seq_axes[name]
            row = 1 if row == '' else int(row)
            # Construct the final Plotly figure with all_shapes
            fig.append_trace(go.Bar(x=[],
                                    y=[]), row=row, col=1)
            fig.layout['xaxis' + seq_axes[name]]['range'] = [init_s, init_e]
            fig.layout['yaxis' + seq_axes[name]]['range'] = [min_neg_height - height_padding,
                                                                   max_pos_height + height_padding]
            fig.layout['xaxis' + seq_axes[name]]['visible'] = False
            # fig.layout['yaxis' + seq_axes[name]]['visible'] = False
            fig.layout['xaxis' + seq_axes[name]]['matches'] = 'x'
            all_shapes += all_shapes_



        v = _bigwig_footprint(group_bigwig[name],
                              group_bigwig['bias'],
                              chrom, init_s, init_e,
                              100)
        x = np.arange(init_s, init_e)
        heatmap = go.Heatmap(z=v, x=x, zmin=vmin, zmax=vmax, colorscale="Blues",
                             showscale=True if i == 0 else False,
                             hoverinfo='skip', )
        row = footprint_axes[name]
        row = 1 if row == '' else int(row)
        # Traces_add to row = 2,3,4...
        fig.add_trace(
            heatmap,
            row=row, col=1
        )
        # Force the xrange to be matched
        fig.layout['xaxis' + footprint_axes[name]]['matches'] = 'x'

    fig.update_layout(
        shapes=all_shapes,
        plot_bgcolor='rgba(0, 0, 0, 0)',
        # paper_bgcolor='rgba(0, 0, 0, 0)',
    )


    if annotation_first > 0:
        fig.layout['xaxis']['visible'] = False
        fig.layout['yaxis']['visible'] = False

    fig.update_yaxes(fixedrange=True)
    fig.update_xaxes(autorange=False)

    # Now footprints starts with xaxis2
    fig.layout.xaxis.range = [init_s, init_e]
    fig.layout.title = f"{chrom}: {init_s}-{init_e}"
    fig.layout.width=width
    fig.layout.height=fig_height
    fig = go.FigureWidget(fig)
    fig.data[footprint_data_start].colorbar.len= 0.3 / len(group_names)
    fig.data[footprint_data_start].colorbar.y = 0.5
    fig.data[footprint_data_start].colorbar.ypad = 0.0
    fig.data[footprint_data_start].colorbar.yanchor = 'bottom'
    fig['layout']['barmode'] = 'overlay'

    for i in fig['layout']['annotations']:
        i['font'] = dict(size=12)


    def change_data(self, xrange):
        xrange_zoom_min, xrange_zoom_max = fig.layout.xaxis.range[0], fig.layout.xaxis.range[1]
        s, e = int(xrange_zoom_min), int(xrange_zoom_max)
        max_level = 0
        trace = -1
        update_track = {}
        with fig.batch_update():
            if motif_scanner is not None:
                df = _create_motif_match_df(motif_scanner, chrom, s, e)
                if df is not None:
                    df.index = df['TF']
                for trace, tf in enumerate(tfs[::-1]):
                    try:
                        tf_df = df.loc[tf]
                        base, x, y = np.array(tf_df['Start']), np.array(tf_df['delta']), np.array(tf_df['Level'])
                        max_level = max(max_level, np.max(y))
                    except:
                        base, x, y = [], [], []
                    update_track[trace] = ({'x':x, 'y':y, 'base':base})

            if gffdb is not None:
                df = _create_gene_match_df(gffdb, chrom, s, e)
                try:
                    base, x, y, gene, strand = (np.array(df['Start']), np.array(df['delta']),
                                                np.array(df['Level']), np.array(df['Gene']),
                                                np.array(df['Strand']))
                    y = y + float(max_level) + 1
                except:
                    base, x, y, gene, strand = [], [], [], [], []
                gene = [xx + "(" + yy + ")" for xx, yy in zip(gene, strand)]
                update_track[trace+1] = ({
                    'x':x,
                    'y':y,
                    'base':base,
                    'text':gene})


            if (e - s) > 1000:
                step = int((e - s) / 1000)
            else:
                step = 1
            x = np.arange(s, e, step)
            offset = 0
            all_shapes = []
            for i, name in enumerate(group_names):
                if name in group_seq_importance:
                    importance = group_seq_importance[name].values(chrom, s, e)
                    importance = np.nan_to_num(importance)
                    seq = printer.genome.fetch_seq(chrom, s, e)
                    seq_imp = parse_seq_importance(seq, importance)
                    xref = 'x' + seq_axes[name]
                    yref = 'y' + seq_axes[name]
                    (all_shapes_, min_neg_height,
                     max_pos_height, height_padding) = plotly_plot_weights(seq_imp,
                                                                           xref=xref,
                                                                           yref=yref,
                                                                           start_pos=s)
                    fig.layout['yaxis' + seq_axes[name]]['range'] = [min_neg_height - height_padding,
                                                                           max_pos_height + height_padding]
                    if i > 0:
                        offset += 1
                    all_shapes += all_shapes_


                v = _bigwig_footprint(group_bigwig[name],
                                      group_bigwig['bias'],
                                      chrom, s, e,
                                      100)[:, ::step]
                # print (v)
                update_track[footprint_data_start + i + offset] = ({'z':v,
                                                      'x':x})





            for trace in update_track:
                fig.data[trace].update(update_track[trace])

            fig.layout.title = f"{chrom}: {s:,}-{e:,}"
            if len(all_shapes) > 0:
                # Construct the final Plotly figure with all_shapes
                # fig.layout['xaxis%d' % (annotation_first)]['range'] = [s, e]

                fig.layout['shapes'] = all_shapes

        return fig
    # print (fig)
    fig.layout.on_change(change_data, 'xaxis.range')

    return fig

